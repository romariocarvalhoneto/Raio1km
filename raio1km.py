# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Raio1Km
                                 A QGIS plugin
 Cria Raio de 1 km da ANM
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-04-24
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Romário Moraes Carvalho Neto
        email                : romariocarvalho@hotmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtWidgets import QPushButton
from qgis.gui import QgsMapLayerComboBox
from qgis.core import (QgsMapLayerProxyModel, QgsPoint, QgsVectorLayer, QgsCoordinateReferenceSystem,
                     QgsFeature, QgsGeometry, QgsProject, QgsFillSymbol, QgsCoordinateTransform, QgsLayerTree,
                     QgsPrintLayout, QgsReadWriteContext, QgsSingleSymbolRenderer,QgsLineSymbol)
from qgis.PyQt.QtXml import QDomDocument
from qgis import processing
from qgis.utils import iface

from operator import itemgetter
import time, os.path

# Initialize Qt resources from file resources.py
from .resources import *


class Raio1Km:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        self.iface = iface
        self.mapLayerComboBox = None
        self.button_ok = None
        self.buttonOnOff = None
        plugin_dir = os.path.dirname(__file__)
        self.tmpfile = f'{plugin_dir}\\raio1km.qpt'
        self.root = QgsLayerTree()   ### IMPORTANTE ser atributo da classe para não quebrar o QGIS toda a vez
                                     ### que faz várias vezes o desenho

    def initGui(self):
        """Create the QgsMapLayerComboBox and button inside the QGIS GUI."""

        self.mapLayerComboBox = QgsMapLayerComboBox(self.iface.mainWindow())
        self.mapLayerComboBox.setFixedWidth(140)
        self.mapLayerComboBox.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.mapLayerComboBox.setToolTip('Selecione ANM')
        self.mapLayerComboBox.activated.connect(self.changeButtonStateToOn)

        self.button_ok = QPushButton(self.iface.mainWindow())
        self.button_ok.setFixedWidth(60)
        self.button_ok.setText('Raio 1 Km')
        self.button_ok.setToolTip('Faz o Desenho')
        self.button_ok.setEnabled(False)
        self.button_ok.clicked.connect(self.desenho) #self.run)

        self.mapComboBox_icone = self.iface.addToolBarWidget(self.mapLayerComboBox)
        self.button_icone = self.iface.addToolBarWidget(self.button_ok)

        
    def unload(self):
        """Removes the plugin from QGIS GUI."""

        self.iface.removeToolBarIcon(self.mapComboBox_icone)
        self.iface.removeToolBarIcon(self.button_icone)


    def changeButtonStateToOn(self):
        """Change the button state to on"""
        self.button_ok.setEnabled(True)
            

    def layout_imagem(self, nome_layout):
        """Abre o modelo layout pronto. """

        root = self.root

        project = QgsProject.instance()
        layout = QgsPrintLayout(project)
        layout.initializeDefaults()  #importante para gerar imagem depois

        layout.setName(f"imagem raio 1km {nome_layout}")
        project.layoutManager().addLayout(layout)

        with open(self.tmpfile) as f:
            template_content = f.read()
        doc = QDomDocument()
        doc.setContent(template_content)

        #----adding to existing items
        items, ok = layout.loadFromTemplate(doc, QgsReadWriteContext(), False)

        #----set map extent to match main canvas extent
        items[-1].zoomToExtent(iface.mapCanvas().extent())
        items[-1].setScale(20000, True)

        """Gathers active layers to add to legend"""
        #----Checks layer tree objects and stores them in a list. This includes csv tables
        checked_layers = [layer.name() for layer in QgsProject().instance().layerTreeRoot().children() if layer.isVisible()]

        #----get map layer objects of checked layers by matching their names and store those in a list
        layersToAdd = [layer for layer in QgsProject().instance().mapLayers().values() if layer.name() in checked_layers and layer.type() == 0]
        layersToAdd.reverse()
        # root = QgsLayerTree()  ### Precisa ser self.root se não o QGIS crushes
        for layer in layersToAdd:
            #add layer objects to the layer tree
            root.addLayer(layer)
        
        # """This adds a legend item to the Print Layout"""
        legend = items[-2] 
        legend.model().setRootGroup(root)
        layout.addLayoutItem(legend)
        self.legend_root = root

        return layout


    def desenho(self):
        '''Faz os cálculos e os desenhos necessários'''

        pegar_codigo = QgsVectorLayer("LineString?crs=epsg:31982&field=id:integer&index=yes","ANM_UTM","memory")
        codigo_UTM = pegar_codigo.crs().authid()

        poligono_ANM = self.mapLayerComboBox.currentLayer() #iface.activeLayer()

        nome_poligono = poligono_ANM.name()

        # --> Mudar de Embedded symbols para single symbol
        # Obtendo o objeto com Embedded symbols
        embedded_renderer = poligono_ANM.renderer()

        # Convertendo para um objeto de Single symbol
        single_symbol_renderer = QgsSingleSymbolRenderer.convertFromRenderer(embedded_renderer)

        # Aplicando o novo objeto de Single symbol ao layer
        poligono_ANM.setRenderer(single_symbol_renderer)

        #----muda a cor do polígono ANM
        symbol = QgsFillSymbol.createSimple({'style': 'no',
                                            'outline_color': 'yellow',
                                            'outline_width': '0.35'})
        poligono_ANM.renderer().setSymbol(symbol)
        poligono_ANM.triggerRepaint()
        iface.layerTreeView().refreshLayerSymbology(poligono_ANM.id())

        if poligono_ANM.crs().authid() != codigo_UTM:
            try:
                sFeat = poligono_ANM.getFeature(0)
                sGeom = sFeat.geometry().asMultiPolygon()

            except:
                sFeat = poligono_ANM.getFeature(1)
                sGeom = sFeat.geometry().asMultiPolygon()

            lista_vertices = sGeom[0][0]    #pt_1 = sGeom[0][0][0] #pt_2 = sGeom[0][0][1]
            lista_transformada = []

            crsSrc = QgsCoordinateReferenceSystem(poligono_ANM.crs().authid()) #poligono_ANM.sourceCrs()
            crsDest = QgsCoordinateReferenceSystem(codigo_UTM)
            transformContext = QgsProject.instance().transformContext()
            xform = QgsCoordinateTransform(crsSrc, crsDest, transformContext)

            for vertice in lista_vertices:
                vertice_transformado = xform.transform(vertice)   #.asMultiPolygon()))
                lista_transformada.append(QgsPoint(vertice_transformado))
                #lista_transformada.append(vertice_transformado)

            pegar_codigo.startEditing()
            feature = QgsFeature()
            #feature.setGeometry(QgsGeometry.fromMultiPointXY(lista_transformada))
            feature.setGeometry(QgsGeometry.fromPolyline(lista_transformada))
            feature.setAttributes([1])
            pegar_codigo.addFeature(feature)
            pegar_codigo.commitChanges()
            #QgsProject.instance().addMapLayer(pegar_codigo)

            poligono_UTM = processing.run("qgis:polygonize", { 'INPUT' : pegar_codigo,
                                                            'KEEP_FIELDS' : True, 
                                                            'OUTPUT' : 'TEMPORARY_OUTPUT' })
            
            #poligono_ANM = poligono_UTM['OUTPUT']
            #QgsProject.instance().addMapLayer(poligono_UTM['OUTPUT'])

            multi_Polygon = processing.run("native:promotetomulti", {'INPUT':poligono_UTM['OUTPUT'],
                                                                    'OUTPUT':'TEMPORARY_OUTPUT'})
            
            poligono_ANM = multi_Polygon['OUTPUT'] #servirá apenas para os cálculos
            #QgsProject.instance().addMapLayer(poligono_ANM)

        #----circulo que engloba a poligonal
        circulo = processing.run("qgis:minimumboundinggeometry", {'INPUT': poligono_ANM,
                                                                'TYPE': 2,
                                                                'OUTPUT': 'TEMPORARY_OUTPUT'})

        poligono_layer = circulo['OUTPUT']   #QgsVectorLayer(SAIDA, "SAIDA", "ogr")
        #QgsProject.instance().addMapLayer(poligono_layer)

        #----criar centroide do circulo
        centroid = processing.run("native:centroids", {'INPUT': poligono_layer,
                                                    'OUTPUT': 'TEMPORARY_OUTPUT'})

        centroid_layer = centroid['OUTPUT']  #QgsVectorLayer(centroid, "centroid", "ogr")
        #QgsProject.instance().addMapLayer(centroid_layer)

        # #----medir o raio  ### USADO caso faça buffer do centroid pelo raio + 1 km, mas está dando dist menor q 1km
        # features = poligono_layer.getFeatures()
        # for f in features:
        #     lista = f.attributes()
        #     raio = lista[1]
        #     break

        #----buffer de raio 1 km + raio circulo
        # raio_final = raio + 1000
        # saida_raio_1km = processing.run("native:buffer", {'INPUT': centroid_layer,
        #                                                 'DISTANCE': raio_final,
        #                                                 'SEGMENTS': 20,
        #                                                 'END_CAP_STYLE': 0, 
        #                                                 'JOIN_STYLE': 0,
        #                                                 'MITER_LIMIT': 2,
        #                                                 'DISSOLVE': False,
        #                                                 'OUTPUT': 'TEMPORARY_OUTPUT'})
        
        #----buffer de 1 km a partir do minimumboundinggeometry circular
        saida_raio_1km = processing.run("native:buffer", {'INPUT': poligono_layer,
                                                        'DISTANCE': 1000,
                                                        'SEGMENTS': 100,
                                                        'END_CAP_STYLE': 0, 
                                                        'JOIN_STYLE': 0,
                                                        'MITER_LIMIT': 2,
                                                        'DISSOLVE': False,
                                                        'OUTPUT': 'TEMPORARY_OUTPUT'})

        raio_1km_layer = saida_raio_1km['OUTPUT']  #QgsVectorLayer(saida_raio_1km, "raio 1 km", "ogr")

        raio_1km_layer.setName('Área de Influência')
        symbol = QgsFillSymbol.createSimple({'style': 'no',
                                            'outline_color': 'red',
                                            'outline_width': '0.35'})
        raio_1km_layer.renderer().setSymbol(symbol)
        QgsProject.instance().addMapLayer(raio_1km_layer)

        #----desenhar linha do ponto mais extremo do poligono até o raio
        try:
            sFeat = poligono_ANM.getFeature(0)
            sGeom = sFeat.geometry().asMultiPolygon()
            lista_vertices = sGeom[0][0]    #pt_1 = sGeom[0][0][0] #pt_2 = sGeom[0][0][1]

        except:    
            sFeat = poligono_ANM.getFeature(1)
            sGeom = sFeat.geometry().asMultiPolygon()
            lista_vertices = sGeom[0][0]    #pt_1 = sGeom[0][0][0] #pt_2 = sGeom[0][0][1]

        feat_centroid = centroid_layer.getFeature(1)
        geom_centroid = feat_centroid.geometry().asPoint()

        lista_vertice_e_dist = []

        #pega a distâncias do centro ao vertice
        for vertices in lista_vertices:
            dist_m = geom_centroid.distance(vertices)
            lista_vertice_e_dist.append((vertices,dist_m))
            
        ordem = sorted(lista_vertice_e_dist,key=itemgetter(1))

        ponto_mais_dist = ordem[-1][0]   #print('ponto', ordem[-1][0])

        pt_inicio = QgsPoint(geom_centroid)
        pt_fim = QgsPoint(ponto_mais_dist)

        PointList = [pt_inicio, pt_fim]

        #----usar extend para aumentar a linha que vai do centroide ao vertice mais distante até chegar ao raio de 1000 m
        linea2 = QgsVectorLayer("LineString?crs=epsg:31982&field=id:integer&index=yes","Linea2","memory")
        linea2.startEditing()
        feature2 = QgsFeature()
        feature2.setGeometry(QgsGeometry.fromPolyline(PointList).extendLine(0.0, 1100.0))
        feature2.setAttributes([1])
        linea2.addFeature(feature2)
        linea2.commitChanges()
        #QgsProject.instance().addMapLayer(linea2)

        # # clipar linha criada do centroide ao raio final por poligono circulo menos ANM
        # mascara_clip = processing.run("native:difference", {'INPUT' : raio_1km_layer,
        #                                                     'OVERLAY': poligono_ANM,
        #                                                     'OUTPUT' : 'TEMPORARY_OUTPUT'})

        #----clipar linha criada do centroide ao raio final por poligono circulo menos poligono circulo menor
        mascara_clip = processing.run("native:difference", {'INPUT' : raio_1km_layer,
                                                            'OVERLAY': poligono_layer,
                                                            'OUTPUT' : 'TEMPORARY_OUTPUT'})
        #QgsProject.instance().addMapLayer(mascara_clip['OUTPUT'])

        linha_final = processing.run("native:clip", {'INPUT' : linea2,
                                                    'OVERLAY': mascara_clip['OUTPUT'],
                                                    'OUTPUT' : 'TEMPORARY_OUTPUT'})
        linha_final['OUTPUT'].setName('Raio de 1 km a partir da extremidade da área de extração')

        symbol = QgsLineSymbol.createSimple({'color': '0,220,36,255'})
        linha_final['OUTPUT'].renderer().setSymbol(symbol)
        QgsProject.instance().addMapLayer(linha_final['OUTPUT'])

        try:
            layout_preenchido = self.layout_imagem(nome_poligono)
            iface.openLayoutDesigner(layout_preenchido)
            
        except:
            timestr = time.strftime("%Y%m%d-%H%M%S")
            layout_preenchido = self.layout_imagem(f"{nome_poligono}_{timestr}")
            iface.openLayoutDesigner(layout_preenchido)

        self.button_ok.setEnabled(False)
        ## TODO: adicionar apenas os shapes criados por aqui e não todos os que estão no QGIS
        ## BUG: Quando usa o Plugin e depois desabilita e habilita o plugin de novo, o QGIS quebra
        ## TESTAR para debugging: substituir as funções por prints simples e rodar. Ir simplificando, mantendo os métodos
        ## até achar o que está errado. Em último caso, mandar em fórum a vesão simplificada.